paste("charset partD =", paste(partD, collapse=' '), ";"),
"",
"partition chartype=4: partA, partB, partC, partD;",
"set partition=chartype;",
"",
mrBayesTemplate[(insertLine + 1L):length(mrBayesTemplate)])
outputFile <- paste0(bayesFilesDir, '/', ourFile, '.', i, '.nex')
writeLines(mrBayesOutput, outputFile)
}
}
datasetName <- "CEA"
rootDir <- paste0("C:/local/dxsb43/GitHub/Partitioning_Strategies/mutations/", datasetName)
setwd(rootDir)
shellTemplateFile <- '../shell_TEMPLATE.sh.txt'
shellTemplate <- readLines(shellTemplateFile)
shellDir <- "ShellScripts"
if (!dir.exists(shellDir)) dir.create(shellDir)
m <- "NNI_chain"    ##set tree generation method
chunk1 <- c(1:20)
chunk2 <- c(21:40)
chunk3 <- c(41:60)
chunk4 <- c(61:80)
chunk5 <- c(81:100)
chunks <- list(chunk1, chunk2, chunk3, chunk4, chunk5)
for (howManyTrees in chunks) {
lines <- character(length(howManyTrees))
for (k in 1:length(howManyTrees)) {
lines[k] <- paste0('mpirun -n $SLURM_NTASKS mb /ddn/data/dxsb43/mutate',datasetName,
'/',datasetName,'_',m,'/',datasetName,'_',m,'.nex.',howManyTrees[k],'.nex')
}
shellOutput <- c(shellTemplate,
lines,
""
)
shellOutputFile <- paste0(shellDir, '/', datasetName, '_',m,'_', min(howManyTrees), '_', max(howManyTrees),
'.sh')  ##name of .sh file
#cat(shellOutput, file=shellOutputFile, sep="\n")
writeLines(shellOutput, shellOutputFile, sep="\n")
}
m <- "random"    ##set tree generation method
chunk1 <- c(1:20)
chunk2 <- c(21:40)
chunk3 <- c(41:60)
chunk4 <- c(61:80)
chunk5 <- c(81:100)
chunks <- list(chunk1, chunk2, chunk3, chunk4, chunk5)
for (howManyTrees in chunks) {
lines <- character(length(howManyTrees))
for (k in 1:length(howManyTrees)) {
lines[k] <- paste0('mpirun -n $SLURM_NTASKS mb /ddn/data/dxsb43/mutate',datasetName,
'/',datasetName,'_',m,'/',datasetName,'_',m,'.nex.',howManyTrees[k],'.nex')
}
shellOutput <- c(shellTemplate,
lines,
""
)
shellOutputFile <- paste0(shellDir, '/', datasetName, '_',m,'_', min(howManyTrees), '_', max(howManyTrees),
'.sh')  ##name of .sh file
#cat(shellOutput, file=shellOutputFile, sep="\n")
writeLines(shellOutput, shellOutputFile, sep="\n")
}
m <- "TBR_chain"    ##set tree generation method
chunk1 <- c(1:20)
chunk2 <- c(21:40)
chunk3 <- c(41:60)
chunk4 <- c(61:80)
chunk5 <- c(81:100)
chunks <- list(chunk1, chunk2, chunk3, chunk4, chunk5)
for (howManyTrees in chunks) {
lines <- character(length(howManyTrees))
for (k in 1:length(howManyTrees)) {
lines[k] <- paste0('mpirun -n $SLURM_NTASKS mb /ddn/data/dxsb43/mutate',datasetName,
'/',datasetName,'_',m,'/',datasetName,'_',m,'.nex.',howManyTrees[k],'.nex')
}
shellOutput <- c(shellTemplate,
lines,
""
)
shellOutputFile <- paste0(shellDir, '/', datasetName, '_',m,'_', min(howManyTrees), '_', max(howManyTrees),
'.sh')  ##name of .sh file
#cat(shellOutput, file=shellOutputFile, sep="\n")
writeLines(shellOutput, shellOutputFile, sep="\n")
}
require(TreeSearch)
require(ape)
require(phangorn)
# Define constants
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
insertionComment <- "INSERT PARTITIONS HERE"
bayesFilesDir <- 'MrBayes'
# Select dataset
datasetName <- "CEA"
rootDir <- paste0("C:/local/dxsb43/GitHub/Partitioning_Strategies/mutations/", datasetName)
setwd(rootDir)
mrBayesTemplateFile <- paste0(rootDir, '/', datasetName, '_TEMPLATE.nex')
dataset <- ReadAsPhyDat(mrBayesTemplateFile)
# Mr Bayes template
mrBayesTemplate <- readLines(mrBayesTemplateFile)
insertLine <- grep(insertionComment, mrBayesTemplate)
if (!dir.exists(bayesFilesDir)) dir.create(bayesFilesDir)
powerOf2 <- 2^(0:ncol(attr(dataset, "contrast"))) #contrast shows the possible permutations of
#the character states, i.e. 0, 1, 2, 3, 4, 5, {01}, {02} etc.
decode <- apply(attr(dataset, "contrast"), 1, function(r) #
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(dataset, I, dataset[[1]])) # translates lists of taxa and character data into matrix
tab <- tab[, attr(dataset, 'index')]
nChar <- ncol(tab)
chars <- seq_len(nChar)
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
#make MrBayes files from perturbed trees
for (ourFile in list.files('StartingTrees', pattern='*.nex')) {
trees <- read.nexus(paste0('StartingTrees/', ourFile))
for (i in seq_along(trees)) {
tree <- trees[[i]]
parsScore <- Fitch(tree, dataset)
#calculate number to go in exp() for branch lengths prior
expVal <- ncol(tab)/parsScore
obsSteps <- FitchSteps(tree, dataset)
obsSteps <- obsSteps[attr(dataset, 'index')] #if two characters have the same profile, they are now not collapsed into one
#calculate Goloboff's unbiased measure of homoplasy for a given k (concavity constant) and data set
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
#rank characters by homoplasy values and then divide equally into a number of partitions
mat <- rbind(chars, f) #combine char no. and homoplasy value into one matrix
sortedMat <- mat[, order(f)] #sort columns by homoplasy (f) in ascending order
chunk <- round(prop * nChar) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : nChar]
mrBayesOutput <- c(mrBayesTemplate[seq_len(insertLine - 1)],
paste("prset brlenspr = unconstrained: exp(",expVal, ");"),
paste("charset partA =", paste(partA, collapse=' '), ";"),
paste("charset partB =", paste(partB, collapse=' '), ";"),
paste("charset partC =", paste(partC, collapse=' '), ";"),
paste("charset partD =", paste(partD, collapse=' '), ";"),
"",
"partition chartype=4: partA, partB, partC, partD;",
"set partition=chartype;",
"",
mrBayesTemplate[(insertLine + 1L):length(mrBayesTemplate)])
outputFile <- paste0(bayesFilesDir, '/', ourFile, '.', i, '.nex')
writeLines(mrBayesOutput, outputFile)
}
}
rootDir <-"C:/local/dxsb43/GitHub/Partitioning_Strategies/mutations"
inDir <- "SCO"
setwd(paste0(rootDir, inDir))
setwd(paste0(rootDir,'/', inDir))
fl = list.files(inDir, full.names=TRUE)
fl = list.files(full.names=TRUE)
fl = list.files("MrBayes",full.names=TRUE)
#list filenames
oldNames = list.files("MrBayes",full.names=FALSE)
rootDir <-"C:/local/dxsb43/GitHub/Partitioning_Strategies/mutations"
inDir <- "SCO"
setwd(paste0(rootDir,'/', inDir))
if (!dir.exists("MrBayesRenamed")) dir.create("MrBayesRenamed")
#list filenames
oldNames = list.files("MrBayes",full.names=FALSE)
newDir <- "MrBayesRenamed"
oldDir <- "MrBayes"
file.copy(from=oldDir, to=newDir)
if (!dir.exists(newDir)) dir.create(newDir)
file.copy(from=oldDir, to=newDir)
file.copy(from=paste0('/',oldDir), to=paste0('/',newDir))
file.copy(oldNames,from=paste0('/',oldDir), to=paste0('/',newDir))
#list filenames
oldNames <- list.files("MrBayes",full.names=FALSE)
#list filenames
oldNames <- list.files("MrBayesRenamed",full.names=TRUE)
# rename files to consistent format
require(stringr)
rootDir <-"C:/local/dxsb43/GitHub/Partitioning_Strategies/mutations"
inDir <- "SCO"
setwd(paste0(rootDir,'/', inDir))
newDir <- "MrBayesRenamed"
if (!dir.exists(newDir)) dir.create(newDir)
#list filenames
oldNames <- list.files("MrBayesRenamed",full.names=TRUE)
#construct new filenames
pattern <- '_varExpVal'
newNames <- str_replace(oldNames,pattern, '')  ##remove the _varExpVal
#rename files
file.rename(from=oldNames, to=newNames)
#list filenames
oldNames <- list.files("MrBayes",full.names=TRUE)
#construct new filenames
pattern <- '_varExpVal'
newNames <- str_replace(oldNames,pattern, '')  ##remove the _varExpVal
#rename files
file.rename(from=oldNames, to=newNames)
#to go into the for loop
ourFile <- 'SCO_NNI_chain_1to20.out'
outFiles <- readLines(ourFile)
#set dataset and perturbation move
dataSet <- "SCO"              #CEA, OZL, SCO, SYL, THER
perturbMove <- "NNI_chain"       #random, NNI_chain, TBR_chain
#read in .out file
rootDir <-"C:/local/dxsb43/GitHub/Partitioning_Strategies/mutations"
setwd(paste0(rootDir, '/', dataSet, '/', 'MrBayes'))
#to go into the for loop
ourFile <- 'SCO_NNI_chain_1to20.out'
outFiles <- readLines(ourFile)
outFile <- readLines(ourFile)
require(stringr)
setwd(paste0(rootDir, '/', dataSet, '/', 'MrBayesExperimental'))
#to go into the for loop
ourFile <- 'SCO_NNI_chain_1to20.out'
outFile <- readLines(ourFile)
#to go into the for loop
ourFile <- 'SCO_NNI_chain_1to20.out'
outFile <- readLines(ourFile)
#find title of nexus file within output
str_extract_all(outFile,"Executing file .+nex")
paste0('Executing file \\"/ddn/data/dxsb43/mutate',dataSet,'/',dataSet,'_',perturbMove,'/',dataSet,'_',perturbMove,'.nex_varExpVal.1.nex\\"')
paste0('Executing file ./ddn/data/dxsb43/mutate',dataSet,'/',dataSet,'_',perturbMove,'/',dataSet,'_',perturbMove,'.nex_varExpVal.1.nex.')
#find title of nexus file within output
str_extract_all(outFile,paste0('Executing file ./ddn/data/dxsb43/mutate',dataSet,'/',dataSet,'_',perturbMove,'/',dataSet,'_',perturbMove,'.nex_varExpVal.1.nex.'))
#find title of nexus file within output
str_extract_all(outFile,'Executing file')  ##'Executing file ./ddn/data/dxsb43/mutate',dataSet,'/',dataSet,'_',perturbMove,'/',dataSet,'_',perturbMove,'.nex_varExpVal.1.nex.'
#find title of nexus file within output
str_match_all(outFile,'Executing file')  ##'Executing file ./ddn/data/dxsb43/mutate',dataSet,'/',dataSet,'_',perturbMove,'/',dataSet,'_',perturbMove,'.nex_varExpVal.1.nex.'
#find title of nexus file within output
str_match(outFile,'Executing file')  ##'Executing file ./ddn/data/dxsb43/mutate',dataSet,'/',dataSet,'_',perturbMove,'/',dataSet,'_',perturbMove,'.nex_varExpVal.1.nex.'
#find title of nexus file within output
str_match_first(outFile,'Executing file')  ##'Executing file ./ddn/data/dxsb43/mutate',dataSet,'/',dataSet,'_',perturbMove,'/',dataSet,'_',perturbMove,'.nex_varExpVal.1.nex.'
str(outFile)
length(outFile)
length(outFile)/20
split(outFile, ceiling(seq_along(outFile)/8835))
splits <- split(outFile, ceiling(seq_along(outFile)/8835))
View(splits)
outFile <- scan(ourFile)
outFile <- read.table(ourFile)
require(readr)
install.packages("readr")
require(readr)
outFiles <- read_file(ourFile)
head(outFile)
str(outFile)
outFile <- read_file(ourFile)
str(outFile)
require(TreeSearch)
require(ape)
require(phangorn)
# Define constants
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
insertionComment <- "INSERT PARTITIONS HERE"
bayesFilesDir <- 'MrBayes'
# Select dataset
datasetName <- "THER"
rootDir <- paste0("C:/local/dxsb43/GitHub/Partitioning_Strategies/mutations/", datasetName)
setwd(rootDir)
mrBayesTemplateFile <- paste0(rootDir, '/', datasetName, '_TEMPLATE.nex')
dataset <- ReadAsPhyDat(mrBayesTemplateFile)
# Mr Bayes template
mrBayesTemplate <- readLines(mrBayesTemplateFile)
insertLine <- grep(insertionComment, mrBayesTemplate)
if (!dir.exists(bayesFilesDir)) dir.create(bayesFilesDir)
powerOf2 <- 2^(0:ncol(attr(dataset, "contrast"))) #contrast shows the possible permutations of
#the character states, i.e. 0, 1, 2, 3, 4, 5, {01}, {02} etc.
decode <- apply(attr(dataset, "contrast"), 1, function(r) #
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(dataset, I, dataset[[1]])) # translates lists of taxa and character data into matrix
tab <- tab[, attr(dataset, 'index')]
nChar <- ncol(tab)
chars <- seq_len(nChar)
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
#make MrBayes files from perturbed trees
for (ourFile in list.files('StartingTrees', pattern='*.nex')) {
trees <- read.nexus(paste0('StartingTrees/', ourFile))
for (i in seq_along(trees)) {
tree <- trees[[i]]
parsScore <- Fitch(tree, dataset)
#calculate number to go in exp() for branch lengths prior
expVal <- ncol(tab)/parsScore
obsSteps <- FitchSteps(tree, dataset)
obsSteps <- obsSteps[attr(dataset, 'index')] #if two characters have the same profile, they are now not collapsed into one
#calculate Goloboff's unbiased measure of homoplasy for a given k (concavity constant) and data set
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
#rank characters by homoplasy values and then divide equally into a number of partitions
mat <- rbind(chars, f) #combine char no. and homoplasy value into one matrix
sortedMat <- mat[, order(f)] #sort columns by homoplasy (f) in ascending order
chunk <- round(prop * nChar) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : nChar]
mrBayesOutput <- c(mrBayesTemplate[seq_len(insertLine - 1)],
paste("prset brlenspr = unconstrained: exp(",expVal, ");"),
paste("charset partA =", paste(partA, collapse=' '), ";"),
paste("charset partB =", paste(partB, collapse=' '), ";"),
paste("charset partC =", paste(partC, collapse=' '), ";"),
paste("charset partD =", paste(partD, collapse=' '), ";"),
"",
"partition chartype=4: partA, partB, partC, partD;",
"set partition=chartype;",
"",
mrBayesTemplate[(insertLine + 1L):length(mrBayesTemplate)])
outputFile <- paste0(bayesFilesDir, '/', ourFile, '.', i, '.nex')
writeLines(mrBayesOutput, outputFile)
}
}
datasetName <- "THER"
rootDir <- paste0("C:/local/dxsb43/GitHub/Partitioning_Strategies/mutations/", datasetName)
setwd(rootDir)
shellTemplateFile <- '../shell_TEMPLATE.sh.txt'
shellTemplate <- readLines(shellTemplateFile)
shellDir <- "ShellScripts"
if (!dir.exists(shellDir)) dir.create(shellDir)
m <- "TBR_chain"    ##set tree generation method
chunk1 <- c(1:20)
chunk2 <- c(21:40)
chunk3 <- c(41:60)
chunk4 <- c(61:80)
chunk5 <- c(81:100)
chunks <- list(chunk1, chunk2, chunk3, chunk4, chunk5)
for (howManyTrees in chunks) {
lines <- character(length(howManyTrees))
for (k in 1:length(howManyTrees)) {
lines[k] <- paste0('mpirun -n $SLURM_NTASKS mb /ddn/data/dxsb43/mutate',datasetName,
'/',datasetName,'_',m,'/',datasetName,'_',m,'.nex.',howManyTrees[k],'.nex')
}
shellOutput <- c(shellTemplate,
lines,
""
)
shellOutputFile <- paste0(shellDir, '/', datasetName, '_',m,'_', min(howManyTrees), '_', max(howManyTrees),
'.sh')  ##name of .sh file
#cat(shellOutput, file=shellOutputFile, sep="\n")
writeLines(shellOutput, shellOutputFile, sep="\n")
}
m <- "NNI_chain"    ##set tree generation method
for (howManyTrees in chunks) {
lines <- character(length(howManyTrees))
for (k in 1:length(howManyTrees)) {
lines[k] <- paste0('mpirun -n $SLURM_NTASKS mb /ddn/data/dxsb43/mutate',datasetName,
'/',datasetName,'_',m,'/',datasetName,'_',m,'.nex.',howManyTrees[k],'.nex')
}
shellOutput <- c(shellTemplate,
lines,
""
)
shellOutputFile <- paste0(shellDir, '/', datasetName, '_',m,'_', min(howManyTrees), '_', max(howManyTrees),
'.sh')  ##name of .sh file
#cat(shellOutput, file=shellOutputFile, sep="\n")
writeLines(shellOutput, shellOutputFile, sep="\n")
}
m <- "random"    ##set tree generation method
for (howManyTrees in chunks) {
lines <- character(length(howManyTrees))
for (k in 1:length(howManyTrees)) {
lines[k] <- paste0('mpirun -n $SLURM_NTASKS mb /ddn/data/dxsb43/mutate',datasetName,
'/',datasetName,'_',m,'/',datasetName,'_',m,'.nex.',howManyTrees[k],'.nex')
}
shellOutput <- c(shellTemplate,
lines,
""
)
shellOutputFile <- paste0(shellDir, '/', datasetName, '_',m,'_', min(howManyTrees), '_', max(howManyTrees),
'.sh')  ##name of .sh file
#cat(shellOutput, file=shellOutputFile, sep="\n")
writeLines(shellOutput, shellOutputFile, sep="\n")
}
#calculate consistency indices (CI) for each character over a set of random trees
require(TreeSearch)
require(ape)
require(phangorn)
require(ggplot2)
require(tidyr)
# Select dataset
datasetName <- "THER"
rootDir <- "C:/local/dxsb43/GitHub/Partitioning_Strategies/mutations/"
setwd(rootDir)
mrBayesTemplateFile <- paste0(rootDir, '/',datasetName,'/', datasetName, '_TEMPLATE.nex')
dataset <- ReadAsPhyDat(mrBayesTemplateFile)
##################################################################################################
############################# make a .nex file with 500 random trees #############################
##################################################################################################
reps <- seq_len(500)
File <- function (suffix) paste0(datasetName, '/', datasetName, suffix)
Chain <- function (Func, oTree) {
ret <- vector('list', length(reps))
for (i in reps) {
oTree <- Func(oTree)
ret[[i]] <- oTree
}
structure(ret, class='multiPhylo')
}
inputTree <- read.nexus(paste0(datasetName,'/',datasetName, '_optimal_tree.nex'))
#read optimal tree
inputTree <- read.nexus(paste0(datasetName, '_optimal_tree.nex'))   ###optimal tree is in dir 'mutations', not in dataset subdir
inputTree$edge.length <- NULL
inputLabels <- inputTree$tip.label
inputTree <- multi2di(inputTree)
plot(inputTree)
#functions
File <- function (suffix) paste0('CharStructure/', datasetName, suffix)  ##path and name of the target file
Chain <- function (Func, oTree) {
ret <- vector('list', length(reps))
for (i in reps) {
oTree <- Func(oTree)
ret[[i]] <- oTree
}
structure(ret, class='multiPhylo')
}
#read optimal tree
inputTree <- read.nexus(paste0(datasetName, '_optimal_tree.nex'))   ###optimal tree is in dir 'mutations', not in dataset subdir
inputTree$edge.length <- NULL
inputLabels <- inputTree$tip.label
inputTree <- multi2di(inputTree)
plot(inputTree)
write.nexus(structure(lapply(reps, function (i)
ape::rtree(n = length(inputLabels), br=NULL, tip.label = inputLabels)),
class='multiPhylo'), file=File(paste0('_random_',reps,'.nex')))
##################################################################################################
############################# make a .nex file with 500 random trees #############################
##################################################################################################
#how many trees to write to file
rep <- seq_len(500)
reps <- seq_len(100)
setwd(paste0('C:/local/dxsb43/GitHub/Partitioning_Strategies/mutations/'))
File <- function (suffix) paste0(tla, '/', tla, suffix)
Chain <- function (Func, oTree) {
ret <- vector('list', length(reps))
for (i in reps) {
oTree <- Func(oTree)
ret[[i]] <- oTree
}
structure(ret, class='multiPhylo')
}
tla <- 'THER'
inputTree <- read.nexus(paste0(tla, '_optimal_tree.nex'))
inputTree$edge.length <- NULL
inputLabels <- inputTree$tip.label
inputTree <- multi2di(inputTree)
plot(inputTree)
write.nexus(structure(lapply(reps, function (i)
ape::rtree(n = length(inputLabels), br=NULL, tip.label = inputLabels)),
class='multiPhylo'), file=File('_random.nex'))
paste0('CharStructure/', datasetName, suffix)
File
File
File(paste0('_random_',reps,'.nex'))
length(reps)
write.nexus(structure(lapply(reps, function (i)
ape::rtree(n = length(inputLabels), br=NULL, tip.label = inputLabels)),
class='multiPhylo'), file=File(paste0('_random_',length(rep),'.nex')))
#functions
File <- function (suffix) paste0('CharStructure/', datasetName, suffix)  ##path and name of the target file
write.nexus(structure(lapply(reps, function (i)
ape::rtree(n = length(inputLabels), br=NULL, tip.label = inputLabels)),
class='multiPhylo'), file=File(paste0('_random_',length(rep),'.nex')))
powerOf2 <- 2^(0:ncol(attr(dataset, "contrast"))) #contrast shows the possible permutations of
#the character states, i.e. 0, 1, 2, 3, {01}, {02} etc.
decode <- apply(attr(dataset, "contrast"), 1, function(r)
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(dataset, I, dataset[[1]])) # translates lists of taxa and character data into matrix
tab <- tab[, attr(dataset, 'index')]
nChar <- ncol(tab)
chars <- seq_len(nChar)
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
CImat <- matrix(data=NA,nrow=500, ncol=nChar) ###what argument am i missing here? am i #######preallocating an empty matrix####, or making it from existing data?
colnames(CImat) <- chars
#which trees to calculate CI for
trees <- read.nexus(paste0('CharStructure/', datasetName, '_random500.nex')) # reads all 500 random trees
#which trees to calculate CI for
trees <- read.nexus(paste0('CharStructure/', datasetName, '_random_',length(rep),'.nex')) # reads all 500 random trees
for (i in seq_along(trees)) {
tree <- trees[[i]]
parsScore <- Fitch(tree, dataset)
#calculate number to go in exp() for branch lengths prior
expVal <- ncol(tab)/parsScore
obsSteps <- FitchSteps(tree, dataset)
#calculate Goloboff's unbiased measure of homoplasy for a given k (concavity constant) and data set
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
CImat[i, ] <- f     #fill ith row with the vector of CIs
}  ###################################################### doesn't work because obsSteps and minSteps are different lengths.
warnings()
for (i in seq_along(trees)) {
tree <- trees[[i]]
parsScore <- Fitch(tree, dataset)
#calculate number to go in exp() for branch lengths prior
expVal <- ncol(tab)/parsScore
obsSteps <- FitchSteps(tree, dataset)
obsSteps <- obsSteps[attr(dataset, 'index')] #if two characters have the same profile, they are now not collapsed into one
#calculate Goloboff's unbiased measure of homoplasy for a given k (concavity constant) and data set
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
CImat[i, ] <- f     #fill ith row with the vector of CIs
}  ###################################################### doesn't work because obsSteps and minSteps are different lengths.
#reshape CImat into long format
CImat <- as.data.frame(CImat)
CImat <- gather(CImat, key="character", value="CI", 1:nChar)
ggplot(CImat, aes(character,CI )) +
#  geom_jitter(alpha=0.3) +
scale_x_discrete() +
stat_bin_2d()
