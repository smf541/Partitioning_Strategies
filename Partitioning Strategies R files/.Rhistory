sortedMat <- mat[,order(f)] #sort columns by homoplasy (f) in ascending order
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
chunk <- round(prop*ncol(tab)) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : ncol(sortedMat)]
writeClipboard(as.character(partA))
writeClipboard(as.character(partA))
writeClipboard(as.character(partB))
writeClipboard(as.character(partC))
writeClipboard(as.character(partD))
file <- 'CEA_TBR_chain5.nex'
tree <- read.nexus(file)
data <- ReadAsPhyDat(file)
parsScore <- Fitch(tree, data)
expVal <- ncol(tab)/parsScore
powerOf2 <- 2^(0:ncol(attr(data, "contrast"))) #contrast shows the possible permutations of
decode <- apply(attr(data, "contrast"), 1, function(r) #
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(data, I, data[[1]])) # translates lists of taxa and character data into matrix
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
obsSteps <- FitchSteps(tree, data)
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
f
chars <- 1:ncol(tab)
mat <- rbind(chars, f) #combine char no. and homoplasy value into one matrix
sortedMat <- mat[,order(f)] #sort columns by homoplasy (f) in ascending order
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
chunk <- round(prop*ncol(tab)) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : ncol(sortedMat)]
writeClipboard(as.character(partA))
writeClipboard(as.character(partB))
writeClipboard(as.character(partC))
writeClipboard(as.character(partD))
file <- 'CEA_TBR_chain6.nex'
tree <- read.nexus(file)
data <- ReadAsPhyDat(file)
parsScore <- Fitch(tree, data)
expVal <- ncol(tab)/parsScore
powerOf2 <- 2^(0:ncol(attr(data, "contrast"))) #contrast shows the possible permutations of
decode <- apply(attr(data, "contrast"), 1, function(r) #
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(data, I, data[[1]])) # translates lists of taxa and character data into matrix
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
obsSteps <- FitchSteps(tree, data)
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
f
chars <- 1:ncol(tab)
mat <- rbind(chars, f) #combine char no. and homoplasy value into one matrix
sortedMat <- mat[,order(f)] #sort columns by homoplasy (f) in ascending order
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
chunk <- round(prop*ncol(tab)) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : ncol(sortedMat)]
writeClipboard(as.character(partA))
writeClipboard(as.character(partB))
writeClipboard(as.character(partC))
writeClipboard(as.character(partD))
file <- 'CEA_TBR_chain7.nex'
tree <- read.nexus(file)
data <- ReadAsPhyDat(file)
parsScore <- Fitch(tree, data)
expVal <- ncol(tab)/parsScore
powerOf2 <- 2^(0:ncol(attr(data, "contrast"))) #contrast shows the possible permutations of
decode <- apply(attr(data, "contrast"), 1, function(r) #
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(data, I, data[[1]])) # translates lists of taxa and character data into matrix
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
obsSteps <- FitchSteps(tree, data)
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
f
chars <- 1:ncol(tab)
mat <- rbind(chars, f) #combine char no. and homoplasy value into one matrix
sortedMat <- mat[,order(f)] #sort columns by homoplasy (f) in ascending order
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
chunk <- round(prop*ncol(tab)) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : ncol(sortedMat)]
writeClipboard(as.character(partA))
writeClipboard(as.character(partB))
writeClipboard(as.character(partC))
writeClipboard(as.character(partD))
file <- 'CEA_TBR_chain8.nex'
tree <- read.nexus(file)
data <- ReadAsPhyDat(file)
parsScore <- Fitch(tree, data)
expVal <- ncol(tab)/parsScore
powerOf2 <- 2^(0:ncol(attr(data, "contrast"))) #contrast shows the possible permutations of
decode <- apply(attr(data, "contrast"), 1, function(r) #
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(data, I, data[[1]])) # translates lists of taxa and character data into matrix
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
obsSteps <- FitchSteps(tree, data)
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
f
chars <- 1:ncol(tab)
mat <- rbind(chars, f) #combine char no. and homoplasy value into one matrix
sortedMat <- mat[,order(f)] #sort columns by homoplasy (f) in ascending order
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
chunk <- round(prop*ncol(tab)) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : ncol(sortedMat)]
writeClipboard(as.character(partA))
parsScore <- Fitch(tree, data)
expVal <- ncol(tab)/parsScore
writeClipboard(as.character(partA))
writeClipboard(as.character(partB))
writeClipboard(as.character(partC))
writeClipboard(as.character(partD))
file <- 'CEA_TBR_chain9.nex'
tree <- read.nexus(file)
data <- ReadAsPhyDat(file)
parsScore <- Fitch(tree, data)
expVal <- ncol(tab)/parsScore
powerOf2 <- 2^(0:ncol(attr(data, "contrast"))) #contrast shows the possible permutations of
decode <- apply(attr(data, "contrast"), 1, function(r) #
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(data, I, data[[1]])) # translates lists of taxa and character data into matrix
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
obsSteps <- FitchSteps(tree, data)
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
f
chars <- 1:ncol(tab)
mat <- rbind(chars, f) #combine char no. and homoplasy value into one matrix
sortedMat <- mat[,order(f)] #sort columns by homoplasy (f) in ascending order
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
chunk <- round(prop*ncol(tab)) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : ncol(sortedMat)]
writeClipboard(as.character(partA))
writeClipboard(as.character(partB))
writeClipboard(as.character(partC))
writeClipboard(as.character(partD))
file <- 'CEA_TBR_chain10.nex'
tree <- read.nexus(file)
data <- ReadAsPhyDat(file)
parsScore <- Fitch(tree, data)
expVal <- ncol(tab)/parsScore
powerOf2 <- 2^(0:ncol(attr(data, "contrast"))) #contrast shows the possible permutations of
decode <- apply(attr(data, "contrast"), 1, function(r) #
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(data, I, data[[1]])) # translates lists of taxa and character data into matrix
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
obsSteps <- FitchSteps(tree, data)
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
f
chars <- 1:ncol(tab)
mat <- rbind(chars, f) #combine char no. and homoplasy value into one matrix
sortedMat <- mat[,order(f)] #sort columns by homoplasy (f) in ascending order
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
chunk <- round(prop*ncol(tab)) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : ncol(sortedMat)]
writeClipboard(as.character(partA))
writeClipboard(as.character(partB))
writeClipboard(as.character(partC))
writeClipboard(as.character(partD))
file <- 'CEA_TBR_chain20.nex'
tree <- read.nexus(file)
data <- ReadAsPhyDat(file)
parsScore <- Fitch(tree, data)
expVal <- ncol(tab)/parsScore
powerOf2 <- 2^(0:ncol(attr(data, "contrast"))) #contrast shows the possible permutations of
decode <- apply(attr(data, "contrast"), 1, function(r) #
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(data, I, data[[1]])) # translates lists of taxa and character data into matrix
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
obsSteps <- FitchSteps(tree, data)
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
f
chars <- 1:ncol(tab)
mat <- rbind(chars, f) #combine char no. and homoplasy value into one matrix
sortedMat <- mat[,order(f)] #sort columns by homoplasy (f) in ascending order
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
chunk <- round(prop*ncol(tab)) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : ncol(sortedMat)]
writeClipboard(as.character(partA))
writeClipboard(as.character(partA))
writeClipboard(as.character(partB))
writeClipboard(as.character(partC))
writeClipboard(as.character(partD))
file <- 'CEA_TBR_chain30.nex'
tree <- read.nexus(file)
data <- ReadAsPhyDat(file)
parsScore <- Fitch(tree, data)
expVal <- ncol(tab)/parsScore
powerOf2 <- 2^(0:ncol(attr(data, "contrast"))) #contrast shows the possible permutations of
decode <- apply(attr(data, "contrast"), 1, function(r) #
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(data, I, data[[1]])) # translates lists of taxa and character data into matrix
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
obsSteps <- FitchSteps(tree, data)
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
f
chars <- 1:ncol(tab)
mat <- rbind(chars, f) #combine char no. and homoplasy value into one matrix
sortedMat <- mat[,order(f)] #sort columns by homoplasy (f) in ascending order
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
chunk <- round(prop*ncol(tab)) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : ncol(sortedMat)]
writeClipboard(as.character(partD))
writeClipboard(as.character(partA))
writeClipboard(as.character(partB))
writeClipboard(as.character(partC))
writeClipboard(as.character(partC))
writeClipboard(as.character(partD))
file <- 'CEA_TBR_chain40.nex'
tree <- read.nexus(file)
data <- ReadAsPhyDat(file)
parsScore <- Fitch(tree, data)
expVal <- ncol(tab)/parsScore
powerOf2 <- 2^(0:ncol(attr(data, "contrast"))) #contrast shows the possible permutations of
decode <- apply(attr(data, "contrast"), 1, function(r) #
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(data, I, data[[1]])) # translates lists of taxa and character data into matrix
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
obsSteps <- FitchSteps(tree, data)
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
f
chars <- 1:ncol(tab)
mat <- rbind(chars, f) #combine char no. and homoplasy value into one matrix
sortedMat <- mat[,order(f)] #sort columns by homoplasy (f) in ascending order
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
chunk <- round(prop*ncol(tab)) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : ncol(sortedMat)]
writeClipboard(as.character(partA))
writeClipboard(as.character(partB))
writeClipboard(as.character(partC))
writeClipboard(as.character(partD))
file <- 'CEA_TBR_chain50.nex'
tree <- read.nexus(file)
data <- ReadAsPhyDat(file)
parsScore <- Fitch(tree, data)
expVal <- ncol(tab)/parsScore
powerOf2 <- 2^(0:ncol(attr(data, "contrast"))) #contrast shows the possible permutations of
decode <- apply(attr(data, "contrast"), 1, function(r) #
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(data, I, data[[1]])) # translates lists of taxa and character data into matrix
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
obsSteps <- FitchSteps(tree, data)
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
f
chars <- 1:ncol(tab)
mat <- rbind(chars, f) #combine char no. and homoplasy value into one matrix
sortedMat <- mat[,order(f)] #sort columns by homoplasy (f) in ascending order
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
chunk <- round(prop*ncol(tab)) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : ncol(sortedMat)]
writeClipboard(as.character(partA))
writeClipboard(as.character(partB))
writeClipboard(as.character(partC))
writeClipboard(as.character(partD))
file <- 'CEA_TBR_chain60.nex'
tree <- read.nexus(file)
data <- ReadAsPhyDat(file)
parsScore <- Fitch(tree, data)
expVal <- ncol(tab)/parsScore
powerOf2 <- 2^(0:ncol(attr(data, "contrast"))) #contrast shows the possible permutations of
decode <- apply(attr(data, "contrast"), 1, function(r) #
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(data, I, data[[1]])) # translates lists of taxa and character data into matrix
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
obsSteps <- FitchSteps(tree, data)
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
f
chars <- 1:ncol(tab)
mat <- rbind(chars, f) #combine char no. and homoplasy value into one matrix
sortedMat <- mat[,order(f)] #sort columns by homoplasy (f) in ascending order
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
chunk <- round(prop*ncol(tab)) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : ncol(sortedMat)]
writeClipboard(as.character(partA))
writeClipboard(as.character(partB))
writeClipboard(as.character(partC))
writeClipboard(as.character(partD))
file <- 'CEA_TBR_chain70.nex'
tree <- read.nexus(file)
data <- ReadAsPhyDat(file)
parsScore <- Fitch(tree, data)
expVal <- ncol(tab)/parsScore
powerOf2 <- 2^(0:ncol(attr(data, "contrast"))) #contrast shows the possible permutations of
decode <- apply(attr(data, "contrast"), 1, function(r) #
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(data, I, data[[1]])) # translates lists of taxa and character data into matrix
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
obsSteps <- FitchSteps(tree, data)
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
f
chars <- 1:ncol(tab)
mat <- rbind(chars, f) #combine char no. and homoplasy value into one matrix
sortedMat <- mat[,order(f)] #sort columns by homoplasy (f) in ascending order
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
chunk <- round(prop*ncol(tab)) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : ncol(sortedMat)]
writeClipboard(as.character(partA))
writeClipboard(as.character(partB))
writeClipboard(as.character(partC))
writeClipboard(as.character(partD))
file <- 'CEA_TBR_chain80.nex'
tree <- read.nexus(file)
data <- ReadAsPhyDat(file)
parsScore <- Fitch(tree, data)
expVal <- ncol(tab)/parsScore
powerOf2 <- 2^(0:ncol(attr(data, "contrast"))) #contrast shows the possible permutations of
decode <- apply(attr(data, "contrast"), 1, function(r) #
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(data, I, data[[1]])) # translates lists of taxa and character data into matrix
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
obsSteps <- FitchSteps(tree, data)
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
f
chars <- 1:ncol(tab)
mat <- rbind(chars, f) #combine char no. and homoplasy value into one matrix
sortedMat <- mat[,order(f)] #sort columns by homoplasy (f) in ascending order
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
chunk <- round(prop*ncol(tab)) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : ncol(sortedMat)]
writeClipboard(as.character(partA))
writeClipboard(as.character(partB))
writeClipboard(as.character(partC))
writeClipboard(as.character(partD))
file <- 'CEA_TBR_chain90.nex'
tree <- read.nexus(file)
data <- ReadAsPhyDat(file)
parsScore <- Fitch(tree, data)
expVal <- ncol(tab)/parsScore
powerOf2 <- 2^(0:ncol(attr(data, "contrast"))) #contrast shows the possible permutations of
decode <- apply(attr(data, "contrast"), 1, function(r) #
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(data, I, data[[1]])) # translates lists of taxa and character data into matrix
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
obsSteps <- FitchSteps(tree, data)
k <- 3
f <- (k+1)/(obsSteps+k+1+minSteps)
f
chars <- 1:ncol(tab)
mat <- rbind(chars, f) #combine char no. and homoplasy value into one matrix
sortedMat <- mat[,order(f)] #sort columns by homoplasy (f) in ascending order
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
chunk <- round(prop*ncol(tab)) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : ncol(sortedMat)]
writeClipboard(as.character(partA))
writeClipboard(as.character(partB))
writeClipboard(as.character(partC))
writeClipboard(as.character(partD))
file <- 'CEA_TBR_chain100.nex'
tree <- read.nexus(file)
data <- ReadAsPhyDat(file)
parsScore <- Fitch(tree, data)
expVal <- ncol(tab)/parsScore
powerOf2 <- 2^(0:ncol(attr(data, "contrast"))) #contrast shows the possible permutations of
decode <- apply(attr(data, "contrast"), 1, function(r) #
sum(powerOf2[as.logical(r)])
)
tab <- t(vapply(data, I, data[[1]])) # translates lists of taxa and character data into matrix
minSteps <- apply(tab, 2, function(char)
TreeSearch:::MinimumSteps(decode[char])
)
obsSteps <- FitchSteps(tree, data)
f <- (k+1)/(obsSteps+k+1+minSteps)
k <- 3
f
chars <- 1:ncol(tab)
mat <- rbind(chars, f) #combine char no. and homoplasy value into one matrix
sortedMat <- mat[,order(f)] #sort columns by homoplasy (f) in ascending order
nPart <- 4 #number of partitions
prop <- 1/nPart # proportion of characters per partition
chunk <- round(prop*ncol(tab)) # number of characters per partition
partA <- sortedMat[1, 1:chunk]
partB <- sortedMat[1, (chunk+1) : (2*chunk)]
partC <- sortedMat[1, (2*chunk+1):(3*chunk)]
partD <- sortedMat[1, (3*chunk +1) : ncol(sortedMat)]
writeClipboard(as.character(partD))
writeClipboard(as.character(partA))
writeClipboard(as.character(partB))
writeClipboard(as.character(partC))
writeClipboard(as.character(partD))
parsScore <- Fitch(tree, data)
expVal <- ncol(tab)/parsScore
require(ape)
require(phytools)
require(Quartet)
setwd("C:/Users/dxsb43/GitHub/Partitioning_Strategies/mutations/SCO")
startTree <- read.nexus("sco_homk0_5_trees.nex")
startTree <- read.nexus("sco_homk0_5_trees.nex")
startTree <- read.nexus("comp_sco_homk0_5.nex")
setwd("C:/Users/dxsb43/GitHub/Partitioning_Strategies/mutations")
startTree <- read.nexus("comp_sco_homk0_5.nex")
setwd("C:/Users/dxsb43/GitHub/Partitioning_Strategies/mutations/SCO")
startTree <- read.nexus("sco_homk0_5_trees.nex")
startTree <- read.nexus("comp_homk0_5.nex")
setwd("C:/Users/dxsb43/GitHub/Partitioning_Strategies/mutations")
startTree <- read.nexus("comp_homk0_5.nex")
startTree <- read.nexus("comp_sco_homk0_5.nex")
startTree <- read.nexus("comp_sco_homk0_5.nex")
conTree <- read.nexus("sco_homk0_5.nex.con.tre")
setwd("C:/Users/dxsb43/GitHub/Partitioning_Strategies/mutations/SCO")
conTree <- read.nexus("sco_homk0_5.nex.con.tre")
startTree <- read.nexus("sco_homk0_5_trees.nex")
startTree <- read.nexus("sco_homk0_5_tree.nex")
conTree <- read.nexus("sco_homk0_5.nex.con.tre")
trees <- list(startTree, conTree)
QStrees <- QuartetStatus(trees)
SimilarityMetrics(QStrees)
